"use strict";const e=e=>new Promise((t=>setTimeout(t,e)));class t{_parentElement;constructor(e){this._parentElement=e,this._clear()}makeBorder(e){return`<span style="padding: 10px; margin: 10px; border: 3px solid; border-color: rgb(64, 64, 64); line-height: 5.8;">${e}</span>`}makeColor(e,t){return`<span style="color: rgb(${e[0]}, ${e[1]}, ${e[2]});">${t}</span>`}makeSize(e,t){return`<span style="font-size: ${e}px;">${t}</span>`}alignedLog(e,...t){const i=t.join(" ").split("\n").join("<br>")+"<br>",s=document.createElement("p");s.innerHTML=i,s.style=`text-align: ${e};`,this._parentElement.appendChild(s)}log(...e){this.alignedLog.apply(this,["left",...e])}logLeft(...e){this.alignedLog.apply(this,["left",...e])}logRight(...e){this.alignedLog.apply(this,["right",...e])}logCenter(...e){this.alignedLog.apply(this,["center",...e])}error(...e){this.alignedLog.apply(this,["center","ERR",...e])}_clear(){for(;this._parentElement.firstChild;)this._parentElement.removeChild(this._parentElement.lastChild)}}class i{static _wasmModule;static async load(){var e;await(e="../../build/wasm-cryptopp.js",new Promise(((t,i)=>{const s=document.createElement("script");s.src=e,s.addEventListener("load",t),s.addEventListener("error",i),document.head.appendChild(s)}))),await i.rawLoad()}static async rawLoad(){i._wasmModule=await wasmCryptoppJs({locateFile:e=>(console.log(`url: "${e}"`),`../../build/${e}`)})}static get(){if(!this._wasmModule)throw new Error("crytpopp wasm module not loaded");return this._wasmModule}}const s=(e,t,i,s)=>{const n=t.length.toString();let o=0;for(;o<t.length;){let a=t.substr(o,i);o>0&&(a=a.padEnd(i,"_"));const r=e.makeColor([128,128,64],a);switch(s){case"left":e.alignedLog(s,` => {${o.toString().padStart(3,"_")} / ${n}} ${r}`);break;case"right":e.alignedLog(s,`${r} {${o.toString().padStart(3,"_")} / ${n}} <= `);break;case"center":e.alignedLog(s,`${r}`)}o+=i}};var n;!function(e){e.PlainMessage="PlainMessage",e.EncryptedMessage="EncryptedMessage",e.SecurityRequest="SecurityRequest",e.SecurityResponse="SecurityResponse"}(n||(n={}));const o=e=>"object"==typeof e&&"string"==typeof e.type&&"string"==typeof e.payload;var a;!function(e){e[e.unencrypted=0]="unencrypted",e[e.initiated=1]="initiated",e[e.ready=2]="ready",e[e.confirmed=3]="confirmed"}(a||(a={}));const r=e=>"object"==typeof e&&"string"==typeof e.signedPublicKey,l=e=>r(e),h=(e,t,i)=>{const s=t.length.toString();let n=0;for(;n<t.length;){let o=t.substr(n,i);n>0&&(o=o.padEnd(i,"_")),e(` => {${n.toString().padStart(3,"_")} / ${s}} ${o}`),n+=i}},g="pineapple";class d{_data={};_wasDeleted=!1;_communication;_EncryptedCommunicationState=a.unencrypted;_onReceiveCallbacks=[];_onLogging;_prng;_privateKey;_publicKey;_dhClient;_cipher;constructor(e,t){this._communication=e,this._onLogging=t,this._communication.onReceive((async e=>{await this._processReceivedMessage(e)}))}delete(){this._prng&&(this._prng.delete(),this._prng=void 0),this._privateKey&&(this._privateKey.delete(),this._privateKey=void 0),this._publicKey&&(this._publicKey.delete(),this._publicKey=void 0),this._dhClient&&(this._dhClient.delete(),this._dhClient=void 0),this._cipher&&(this._cipher.delete(),this._cipher=void 0)}async startEncryption_step1(t){const s=i.get();{this._log("------------------------------------"),this._log("Derive Sha256 hash"),this._log(`(from password "${t}")`),this._log("Deriving");const e=Date.now();this._data.password=t;const i="my salt",n="my info",o=332;this._data.derivedKey=s.deriveSha256HexStrKeyFromHexStrData(this._data.password,i,n,o);const a=Date.now();h(this._log.bind(this),this._data.derivedKey,64),this._log(`Derived (${a-e}ms)`),this._log("using derived hash for future input values"),this._data.entropy=this._data.derivedKey.slice(0,100),this._data.nonce=this._data.derivedKey.slice(100,200),this._data.personalization=this._data.derivedKey.slice(200,300),this._data.ivValue=this._data.derivedKey.slice(300,332),this._log("entropy"),h(this._log.bind(this),this._data.entropy,64),this._log("nonce"),h(this._log.bind(this),this._data.nonce,64),this._log("personalization"),h(this._log.bind(this),this._data.personalization,64),this._log("ivValue"),h(this._log.bind(this),this._data.ivValue,64),this._log("------------------------------------")}{this._log("------------------------------------"),this._log("Build the Hash Drbg Random Generator"),this._log("(will use previously derived entropy, nonce, personalization)"),this._log("Building");const e=Date.now();this._prng&&(this._prng.delete(),this._prng=void 0),this._prng=new s.HashDrbgRandomGeneratorJs(this._data.entropy,this._data.nonce,this._data.personalization);const t=Date.now();this._log(`Built (${t-e}ms)`),this._log("------------------------------------")}{this._log("------------------------------------"),this._log("Generate random RSA private key of 3072 bytes"),this._log("(will use the previously setup Hash Drbg Random Generator)"),this._log("Building"),await e(10);const t=Date.now();this._privateKey&&(this._privateKey.delete(),this._privateKey=void 0),this._privateKey=new s.RSAPrivateKeyJs,this._privateKey.generateRandomWithKeySizeUsingHashDrbg(this._prng,3072),this._data.privateKeyPem=this._privateKey.getAsPemString();const i=Date.now();this._log(`Built (${i-t}ms)`),this._log("------------------------------------")}{this._log("------------------------------------"),this._log("Generate random RSA public key"),this._log("(will use the previously setup RSA private key)"),this._log("Building");const e=Date.now();this._publicKey&&(this._publicKey.delete(),this._publicKey=void 0),this._publicKey=new s.RSAPublicKeyJs,this._publicKey.setFromPrivateKey(this._privateKey),this._data.publicKeyPem=this._privateKey.getAsPemString();const t=Date.now();this._log(`Built (${t-e}ms)`),this._log("------------------------------------")}{this._log("------------------------------------"),this._log("Diffie Hellman Key Exchange"),this._log("generating public/private keys"),this._log("2048-bit MODP Group with 256-bit Prime Order Subgroup"),await e(10);const t=Date.now();this._dhClient&&(this._dhClient.delete(),this._dhClient=void 0),this._dhClient=new s.DiffieHellmanClientJs,this._dhClient.generateRandomKeysSimpler(),this._data.dhPublicKey=this._dhClient.getPublicKeyAsHexStr();const i=Date.now();this._log(`generated public/private keys (${i-t}ms)`),this._log("------------------------------------")}{this._log("------------------------------------"),this._log("RSA private key signing"),this._log("sign Diffie Hellman public key"),await e(10);const t=Date.now();this._data.dhSignedPublicKey=this._privateKey.signFromHexStrToHexStrUsingHashDrbg(this._prng,this._data.dhPublicKey);const i=Date.now();this._log(`signed Diffie Hellman public key (${i-t}ms)`),this._log("------------------------------------")}}getSignedPublicKeyAsHexStr(){if(!this._data.dhSignedPublicKey)throw new Error("no _data.dhSignedPublicKey yet");return this._data.dhSignedPublicKey}async syncWithOtherClient_step2(t){if(!this._publicKey)throw new Error("no _publicKey yet");if(!this._dhClient)throw new Error("no _dhClient yet");if(!this._data.ivValue)throw new Error("no _data.ivValue yet");const s=i.get(),n=this._publicKey.verifyFromHexStrToHexStr(t);{this._log("------------------------------------"),this._log("Diffie Hellman Key Exchange"),this._log("shared secret"),this._log("computing"),await e(10);const t=Date.now();this._dhClient.computeSharedSecretFromHexStr(n);const i=Date.now();this._data.sharedSecret=this._dhClient.getSharedSecretAsHexStr(),this._log(`computed (${i-t}ms)`),h(this._log.bind(this),this._data.sharedSecret,64),this._log("------------------------------------")}{this._log("------------------------------------"),this._log("AES Symmetric Cipher"),this._log("(will use previously computed shared secret)"),this._log("(will use previously derived ivValue)");const t=this._data.sharedSecret.slice(0,64);this._log("actual key used"),h(this._log.bind(this),t,32),this._log("actual iv value used"),h(this._log.bind(this),this._data.ivValue,32),this._log("initializing"),await e(10);const i=Date.now();this._cipher&&(this._cipher.delete(),this._cipher=void 0),this._cipher=new s.AesSymmetricCipherJs,this._cipher.initializeFromHexStr(t,this._data.ivValue);const n=Date.now();this._log(`initialized (${n-i}ms)`),this._log("------------------------------------")}}encryptStrToHexStr(e){if(!this._cipher)throw new Error("no _cipher yet");const t=i.get().utf8ToHex(e);return this._cipher.encryptFromHexStrAsHexStr(t)}decryptHexStrToStr(e){if(!this._cipher)throw new Error("no _cipher yet");const t=i.get(),s=this._cipher.decryptFromHexStrAsHexStr(e);return t.hexToUtf8(s)}async makeSecure(){if(this._wasDeleted)throw new Error("was deleted");this._log("now securing the connection"),this._EncryptedCommunicationState=a.initiated,await this.startEncryption_step1(g);const e={signedPublicKey:this.getSignedPublicKeyAsHexStr()},t=JSON.stringify(e);this._communication.send(JSON.stringify({type:n.SecurityRequest,payload:t}))}send(e){if(this._wasDeleted)throw new Error("was deleted");if(this._EncryptedCommunicationState===a.initiated)throw new Error("cannot send while securing the connection");if(this._EncryptedCommunicationState===a.unencrypted)this._log("sending a message:","[unencrypted]"),this._log(`"${e}"`,"[unencrypted]"),this._communication.send(JSON.stringify({type:n.PlainMessage,payload:e}));else{this._log("sending a message:","[encrypted]"),this._log(`"${e}"`,"[encrypted]"),this._log("encrypting","[encrypted]");const t=Date.now(),i=this.encryptStrToHexStr(e),s=Date.now();this._log(`encrypted (${s-t}ms)`,"[encrypted]"),this._communication.send(JSON.stringify({type:n.EncryptedMessage,payload:i}))}}onReceive(e){if(this._wasDeleted)throw new Error("was deleted");this._onReceiveCallbacks.push(e)}get EncryptedCommunicationState(){if(this._wasDeleted)throw new Error("was deleted");return this._EncryptedCommunicationState}async _processReceivedMessage(e){if(this._wasDeleted)throw new Error("was deleted");const t=JSON.parse(e);if(!o(t))throw new Error("received message structure unrecognized");switch(this._log(`received message, type: "${t.type}"`),t.type){case n.PlainMessage:this._onReceiveCallbacks.forEach((e=>e(t.payload)));break;case n.EncryptedMessage:{this._log("decrypting");const e=Date.now(),i=this.decryptHexStrToStr(t.payload),s=Date.now();if(this._log(`decrypted (${s-e}ms)`),this._EncryptedCommunicationState===a.ready)this._log("connection now confirmed secure"),this._EncryptedCommunicationState=a.confirmed;else if(this._EncryptedCommunicationState!==a.confirmed)throw new Error("was expecting to be in a secure state");this._onReceiveCallbacks.forEach((e=>e(i)));break}case n.SecurityRequest:{this._log("now securing the connection"),this._EncryptedCommunicationState=a.initiated;const e=JSON.parse(t.payload);if(!l(e))throw new Error("received message security request payload unrecognized");await this.startEncryption_step1(g);const i={signedPublicKey:this.getSignedPublicKeyAsHexStr()},s=JSON.stringify(i);await this.syncWithOtherClient_step2(e.signedPublicKey),this._log("sending public key"),this._EncryptedCommunicationState=a.ready,this._communication.send(JSON.stringify({type:n.SecurityResponse,payload:s}));break}case n.SecurityResponse:{if(this._log("processing received security response"),this._EncryptedCommunicationState!==a.initiated)throw new Error("was expecting a security response");this._log("computing the shared secret with the received public key");const e=JSON.parse(t.payload);if(!r(e))throw new Error("received message security response payload unrecognized");await this.syncWithOtherClient_step2(e.signedPublicKey),this._log("connection now confirmed secure"),this._EncryptedCommunicationState=a.ready;break}default:throw new Error(`received message type unsupported, type: "${t.type}"`)}}_log(e,t){this._onLogging&&this._onLogging(e,t)}}const c=["/!\\","UNENCRYPTED MESSAGE","ANYONE LISTENING CAN SEE IT","/!\\"].join("\n"),p=["(OK)","ENCRYPTED MESSAGE","GOOD LUCK TO ANYONE LISTENING","(OK)"].join("\n"),_=["(OK)","NO COMPROMISING INFORMATION SHARED","GOOD LUCK TO ANYONE LISTENING","(OK)"].join("\n"),y=(e,t,i)=>{i.type===n.PlainMessage?e.alignedLog(t,e.makeColor([128,64,64],c)):i.type===n.EncryptedMessage?e.alignedLog(t,e.makeColor([64,128,64],p)):i.type!==n.SecurityRequest&&i.type!==n.SecurityResponse||e.alignedLog(t,e.makeColor([64,128,64],_))};class m{_logger;_logTextAlign;_myName;_otherName;_transitionStr;_allSentMessages=[];_allOnReceiveCallbacks=[];constructor(e,t,i,s){this._logger=e,this._logTextAlign=t,this._myName=i,this._otherName=s,this._transitionStr="right"===t?"<-----":"-----\x3e"}send(e){this._logger.alignedLog(this._logTextAlign,`fake websocket "${this._myName}" sent a message\n`),this._logger.alignedLog("center",`"${this._myName}" ${this._transitionStr} "${this._otherName}"`),((e,t,i)=>{const a=JSON.parse(i);if(o(a)){if(y(e,t,a),e.alignedLog(t,"type:"),e.alignedLog(t,e.makeColor([192,192,64],`"${a.type}"`)),a.type===n.PlainMessage)e.alignedLog(t,"payload:"),e.alignedLog(t,e.makeColor([192,64,64],e.makeSize(25,`"${a.payload}"`)));else try{const i=JSON.parse(a.payload);l(i)||r(i)?(e.alignedLog(t,"payload.signedPublicKey:"),s(e,i.signedPublicKey,64,t)):(e.alignedLog(t,"payload:"),s(e,a.payload,64,t))}catch{e.alignedLog(t,"payload:"),s(e,a.payload,64,t)}y(e,t,a)}else e.alignedLog(t,`"${i}"`)})(this._logger,"center",e),this._logger.alignedLog("center",`"${this._myName}" ${this._transitionStr} "${this._otherName}"`),this._logger.alignedLog("center","\n"),this._allSentMessages.push(e)}async receive(e){this._logger.alignedLog(this._logTextAlign,`fake websocket "${this._myName}" received a message`);for(const t of this._allOnReceiveCallbacks)await t(e)}onReceive(e){this._allOnReceiveCallbacks.push(e)}async pipeMessages(e){for(const t of this._allSentMessages)await e.receive(t);this._allSentMessages.length=0}hasMessageToSend(){return this._allSentMessages.length>0}}window.onload=async()=>{const e=Date.now(),s=(e=>{const t=document.querySelector(e);if(!t)throw new Error(`DOM elements not found, id: "${e}"`);return t})("#loggerOutput"),n=new t(s);n.logCenter("page loaded"),n.logCenter(n.makeColor([255,0,0],"\n\nSTART\n\n")),n.logCenter(" loading worker-obtain-cipher-key"),n.logCenter(" loading worker-symmetric-cipher");const o=Date.now();await i.load();const a=Date.now();n.logCenter(`wasmCryptoppJs wasm module loaded (${a-o}ms)`),await(async e=>{e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("Secure Connection Test"))));const t=e.makeColor([192,128,128],"Client A"),i=e.makeColor([128,128,192],"Client B"),s=new m(e,"left",t,i),n=new m(e,"right",i,t);e.logCenter(e.makeBorder("initialize")),e.logLeft(`${t} created`);const o=new d(s,((t,i)=>{i?e.logLeft(`${i} ${t}`):e.logLeft(t)}));e.logRight(`${i} created`);const a=new d(n,((t,i)=>{i?e.logRight(`${t} ${i}`):e.logRight(t)}));o.onReceive((async i=>{e.alignedLog("left",`${t} received:`),e.alignedLog("left",e.makeColor([64,192,64],e.makeSize(25,`"${i}"`))),e.alignedLog("left","\n")})),a.onReceive((async t=>{e.alignedLog("right",`${i} received:`),e.alignedLog("right",e.makeColor([64,192,64],e.makeSize(25,`"${t}"`))),e.alignedLog("right","\n")})),e.logCenter(e.makeBorder("[unencrypted] Client A send to Client B")),e.logLeft(`${t} now sending a message:`);const r="Hello, is this safe?";for(e.alignedLog("left",e.makeColor([64,192,64],e.makeSize(25,`"${r}"`))),e.log("\n"),o.send(r);s.hasMessageToSend()||n.hasMessageToSend();)await s.pipeMessages(n),await n.pipeMessages(s);e.logCenter(e.makeBorder("[unencrypted] Client B send to Client A")),e.logRight(`${i} now sending a message:`);const l="Hi, no... it isn't safe...";for(e.alignedLog("right",e.makeColor([64,192,64],e.makeSize(25,`"${l}"`))),e.log("\n"),a.send(l);s.hasMessageToSend()||n.hasMessageToSend();)await s.pipeMessages(n),await n.pipeMessages(s);for(e.logCenter(e.makeBorder("Client A send request for encryption to Client B")),await o.makeSecure();s.hasMessageToSend()||n.hasMessageToSend();)await s.pipeMessages(n),await n.pipeMessages(s);e.logCenter(e.makeBorder("Client B sent a reply for encryption to Client B")),e.logCenter(e.makeBorder("Both Client A and Client B can now encrypt/decrypt each other messages")),e.logCenter(e.makeBorder("[encrypted] Client A send to Client B")),e.logLeft(`${t} now sending a message:`);const h="Let's try again, safe now?";e.alignedLog("left",e.makeColor([64,192,64],e.makeSize(25,`"${h}"`))),e.log("\n"),o.send(h),await s.pipeMessages(n),e.logCenter(e.makeBorder("[encrypted] Client B send to Client A")),e.logRight(`${i} now sending a message:`);const g="I'd say we're pretty safe right now :)";e.alignedLog("right",e.makeColor([64,192,64],e.makeSize(25,`"${g}"`))),e.log("\n"),a.send(g),await n.pipeMessages(s),o.delete(),a.delete(),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("Secure Connection Test"))))})(n);const r=Date.now();n.logCenter(n.makeColor([255,0,0],`\n\nSTOP (${r-e}ms)\n\n`))};
