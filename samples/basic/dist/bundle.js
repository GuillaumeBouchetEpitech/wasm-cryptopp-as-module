"use strict";class e{_parentElement;constructor(e){this._parentElement=e,this._clear()}makeBorder(e){return`<span style="padding: 10px; margin: 10px; border: 3px solid; border-color: rgb(64, 64, 64); line-height: 5.8;">${e}</span>`}makeColor(e,t){return`<span style="color: rgb(${e[0]}, ${e[1]}, ${e[2]});">${t}</span>`}makeSize(e,t){return`<span style="font-size: ${e}px;">${t}</span>`}alignedLog(e,...t){const r=t.join(" ").split("\n").join("<br>")+"<br>",a=document.createElement("p");a.innerHTML=r,a.style=`text-align: ${e};`,this._parentElement.appendChild(a)}log(...e){this.alignedLog.apply(this,["left",...e])}logLeft(...e){this.alignedLog.apply(this,["left",...e])}logRight(...e){this.alignedLog.apply(this,["right",...e])}logCenter(...e){this.alignedLog.apply(this,["center",...e])}error(...e){this.alignedLog.apply(this,["center","ERR",...e])}_clear(){for(;this._parentElement.firstChild;)this._parentElement.removeChild(this._parentElement.lastChild)}}class t{static _wasmModule;static async load(){var e;await(e="../../build/wasm-cryptopp.js",new Promise(((t,r)=>{const a=document.createElement("script");a.src=e,a.addEventListener("load",t),a.addEventListener("error",r),document.head.appendChild(a)}))),await t.rawLoad()}static async rawLoad(){t._wasmModule=await wasmCryptoppJs({locateFile:e=>(console.log(`url: "${e}"`),`../../build/${e}`)})}static get(){if(!this._wasmModule)throw new Error("crytpopp wasm module not loaded");return this._wasmModule}}const r=(e,t,r,a)=>{const o=t.length.toString();let i=0;for(;i<t.length;){let n=t.substr(i,r);i>0&&(n=n.padEnd(r,"_"));const l=e.makeColor([128,128,64],n);switch(a){case"left":e.alignedLog(a,` => {${i.toString().padStart(3,"_")} / ${o}} ${l}`);break;case"right":e.alignedLog(a,`${l} {${i.toString().padStart(3,"_")} / ${o}} <= `);break;case"center":e.alignedLog(a,`${l}`)}i+=r}},a=async(e,t)=>{const r=Date.now(),a=await e();return t(Date.now()-r),a};window.onload=async()=>{const o=(e=>{const t=document.querySelector(e);if(!t)throw new Error(`DOM elements not found, id: "${e}"`);return t})("#loggerOutput"),i=new e(o);i.logCenter(i.makeColor([255,0,0],"\n\nSTART\n\n")),i.logCenter("page loaded"),i.logCenter(" loading wasmCryptoppJs wasm script");const n=Date.now();await t.load();const l=Date.now()-n;i.logCenter(`wasmCryptoppJs wasm module loaded ${l}ms`),await(async e=>{const o=t.get();e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("AesSymmetricCipher test"))));const i=new o.AutoSeededRandomPoolJs;e.alignedLog("center","generate random key value");const n=i.getRandomHexStr(32);e.alignedLog("center","generate random iv value");const l=i.getRandomHexStr(16);i.delete(),e.logCenter(e.makeBorder("AesSymmetricCipher A: initialize")),e.alignedLog("left","create the AES Symmetric Cipher A");const g=new o.AesSymmetricCipherJs;e.alignedLog("left","initialize the AES Symmetric Cipher A"),e.alignedLog("left","initializing"),await a((()=>{g.initializeFromHexStr(n,l)}),(t=>{e.alignedLog("left",`initialized (${t}ms)`)})),e.logCenter(e.makeBorder("AesSymmetricCipher B: initialize")),e.alignedLog("right","create the AES Symmetric Cipher B");const s=new o.AesSymmetricCipherJs;e.alignedLog("right","initialize the AES Symmetric Cipher B"),e.alignedLog("right","initializing"),await a((()=>{s.initializeFromHexStr(n,l)}),(t=>{e.alignedLog("right",`initialized (${t}ms)`)})),e.logCenter(e.makeBorder("AesSymmetricCipher A: encrypt payload"));const d="This is my plain text message....";e.alignedLog("left",`original payload:  "${e.makeColor([64,192,64],d)}"`);const m=o.utf8ToHex(d);e.alignedLog("left","encrypting");const c=await a((()=>g.encryptFromHexStrAsHexStr(m)),(t=>{e.alignedLog("left",`encrypted (${t}ms)`)}));e.alignedLog("left","encrypted payload:"),r(e,c,32,"left"),e.logCenter(e.makeBorder("AesSymmetricCipher B: decrypt payload")),e.alignedLog("right","encrypted payload:"),r(e,c,32,"right"),e.alignedLog("right","decrypting");const C=await a((()=>g.decryptFromHexStrAsHexStr(c)),(t=>{e.alignedLog("right",`decrypted (${t}ms)`)})),E=o.hexToUtf8(C);e.alignedLog("right",`decrypted payload: "${e.makeColor([128,128,255],E)}"`),e.alignedLog("right",`original payload:  "${e.makeColor([64,192,64],d)}"`),e.logCenter(e.makeBorder("Verification")),E===d?e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([128,255,128]," => SUCCESS: ENCRYPTED PAYLOAD WAS RECOVERED!"))}\n    `):e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([255,128,128]," => FAILURE: ENCRYPTED PAYLOAD WAS NOT RECOVERED!"))}\n    `),g.delete(),s.delete(),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("AesSymmetricCipher test"))))})(i),await(async e=>{const o=t.get();e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("DiffieHellmanClient test"))));const i=e.makeColor([192,128,128],"Client A"),n=e.makeColor([128,128,192],"Client B"),l=["0x87A8E61DB4B6663CFFBBD19C651959998CEEF608660DD0F2","5D2CEED4435E3B00E00DF8F1D61957D4FAF7DF4561B2AA30","16C3D91134096FAA3BF4296D830E9A7C209E0C6497517ABD","5A8A9D306BCF67ED91F9E6725B4758C022E0B1EF4275BF7B","6C5BFC11D45F9088B941F54EB1E59BB8BC39A0BF12307F5C","4FDB70C581B23F76B63ACAE1CAA6B7902D52526735488A0E","F13C6D9A51BFA4AB3AD8347796524D8EF6A167B5A41825D9","67E144E5140564251CCACB83E6B486F6B3CA3F7971506026","C0B857F689962856DED4010ABD0BE621C3A3960A54E710C3","75F26375D7014103A4B54330C198AF126116D2276E11715F","693877FAD7EF09CADB094AE91E1A1597"].join(""),g="0x8CF83642A709A097B447997640129DA299B1A47D1EB3750BA308B0FE64F5FBD3",s=["0x3FB32C9B73134D0B2E77506660EDBD484CA7B18F21EF2054","07F4793A1A0BA12510DBC15077BE463FFF4FED4AAC0BB555","BE3A6C1B0C6B47B1BC3773BF7E8C6F62901228F8C28CBB18","A55AE31341000A650196F931C77A57F2DDF463E5E9EC144B","777DE62AAAB8A8628AC376D282D6ED3864E67982428EBC83","1D14348F6F2F9193B5045AF2767164E1DFC967C1FB3F2E55","A4BD1BFFE83B9C80D052B985D182EA0ADB2A3B7313D3FE14","C8484B1E052588B9B7D2BBD2DF016199ECD06E1557CD0915","B3353BBB64E0EC377FD028370DF92B52C7891428CDC67EB6","184B523D1DB246C32F63078490F00EF8D647D148D4795451","5E2327CFEF98C582664B4C0F6CC41659"].join("");e.logCenter(e.makeBorder(`${i} initialize`)),e.logLeft(`${i} created`);const d=new o.DiffieHellmanClientJs;e.logLeft(`${i} generate keys`),e.alignedLog("left","generating"),await a((()=>{d.generateKeys(l,g,s)}),(t=>{e.alignedLog("left",`generated (${t}ms)`)})),e.logLeft(`${i} provide public key`);const m=d.getPublicKeyAsHexStr();e.logLeft(`${i} public key as hexadecimal value:`),r(e,m,64,"left"),e.log(),e.logCenter(e.makeBorder(`${n} initialize`)),e.logRight(`${n} created`);const c=new o.DiffieHellmanClientJs;e.logRight(`${n} generate keys`),e.alignedLog("right","generating"),await a((()=>{c.generateKeys(l,g,s)}),(t=>{e.alignedLog("right",`generated (${t}ms)`)})),e.logRight(`${n} provide public key`);const C=c.getPublicKeyAsHexStr();e.logRight(`${n} public key as hexadecimal value:`),r(e,C,64,"right"),e.log(),e.logCenter(e.makeBorder(`${i} compute shared secret (with ${n} public key)`)),e.alignedLog("left","computing");const E=await a((()=>(d.computeSharedSecretFromHexStr(C),d.getSharedSecretAsHexStr())),(t=>{e.alignedLog("left",`computed (${t}ms)`)}));e.logLeft(`${i} computed shared secret as hexadecimal value:`),r(e,E,64,"left"),e.log(),e.logCenter(e.makeBorder(`${n} compute shared secret (with ${i} public key)`)),e.alignedLog("right","computing");const p=await a((()=>(c.computeSharedSecretFromHexStr(m),c.getSharedSecretAsHexStr())),(t=>{e.alignedLog("right",`computed (${t}ms)`)}));e.logRight(`${n} computed shared secret as hexadecimal value:`),r(e,p,64,"right"),e.log(),e.logCenter(e.makeBorder("verification")),E==p?e.logCenter(`\n      ${e.makeBorder(e.makeColor([128,255,128]," => SUCCESS: BOTH CLIENTS SHARE THE SAME SECRET!"))}\n    `):e.logCenter(`\n      ${e.makeBorder(e.makeColor([255,128,128]," => FAILURE: CLIENTS SECRETS ARE NOT MATCHING!"))}\n    `),d.delete(),c.delete(),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("DiffieHellmanClient test"))))})(i),await(async e=>{const o=t.get();e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("RSA Features test")))),e.logCenter(e.makeBorder("RSA Features: setup"));const i=new o.AutoSeededRandomPoolJs,n={privateKey:new o.RSAPrivateKeyJs,publicKey:new o.RSAPublicKeyJs},l={privateKey:new o.RSAPrivateKeyJs,publicKey:new o.RSAPublicKeyJs};e.logCenter(e.makeBorder("RSA Features: initialize")),e.alignedLog("center","generate random private key of 3072 bytes (PRIVATE KEY A)"),e.alignedLog("center","generating"),await a((()=>{n.privateKey.generateRandomWithKeySize(i,3072)}),(t=>{e.alignedLog("center",`generated (${t}ms)`)})),e.alignedLog("left",n.privateKey.getAsPemString()),e.alignedLog("center","get public key from the private key (PUBLIC KEY A)"),n.publicKey.setFromPrivateKey(n.privateKey),e.alignedLog("left",n.publicKey.getAsPemString()),e.logCenter(e.makeBorder("RSA Features: PEM GET/LOAD")),e.alignedLog("center","load a new private key (PRIVATE KEY B) from the PEM of the first private key (PRIVATE KEY A)"),l.privateKey.loadFromPemString(n.privateKey.getAsPemString()),e.alignedLog("center","load a new public key (PUBLIC KEY B) from the PEM of the first public key (PUBLIC KEY A)"),l.publicKey.loadFromPemString(n.publicKey.getAsPemString()),e.logCenter(e.makeBorder("RSA Features: SIGN")),e.alignedLog("center","sign some content with the second private key (PRIVATE KEY B)");const g="Hello from JavaScript!";e.alignedLog("center","original payload:"),e.logCenter(e.makeColor([0,128,0],e.makeSize(30,`"${g}"`)));const s=o.utf8ToHex(g);e.alignedLog("center","signing");const d=await a((()=>l.privateKey.signFromHexStrToHexStr(i,s)),(t=>{e.alignedLog("center",`signed (${t}ms)`)}));e.alignedLog("center","signed payload:"),r(e,d,64,"center"),e.logCenter(e.makeBorder("RSA Features: VERIFY")),e.alignedLog("center","verify signed content with the first public key (PUBLIC KEY A)"),e.alignedLog("center","verifying");const m=await a((()=>n.publicKey.verifyFromHexStrToHexStr(d)),(t=>{e.alignedLog("center",`verified (${t}ms)`)})),c=o.hexToUtf8(m);e.alignedLog("center","verified payload:"),e.logCenter(e.makeColor([0,128,0],e.makeSize(30,`"${c}"`))),e.logCenter(e.makeBorder("Verification")),c===g?e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([128,255,128]," => SUCCESS: SIGNED PAYLOAD WAS VERIFIED!"))}\n    `):e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([255,128,128]," => FAILURE: SIGNED PAYLOAD WAS NOT VERIFIED!"))}\n    `),l.publicKey.delete(),l.privateKey.delete(),n.publicKey.delete(),n.privateKey.delete(),i.delete(),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("RSA Features test"))))})(i),await(async e=>{const a=t.get();e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("Derive Key Features test"))));const o=a.deriveSha256HexStrKeyFromHexStrData(a.utf8ToHex("my password"),a.utf8ToHex("my salt"),a.utf8ToHex("my info"),64);e.logCenter(e.makeBorder('Derive key A, password is "my password", size is 64bytes')),r(e,o,32,"center");const i=a.deriveSha256HexStrKeyFromHexStrData(a.utf8ToHex("my password"),a.utf8ToHex("my salt"),a.utf8ToHex("my info"),128);e.logCenter(e.makeBorder('Derive key B, password is "my password", size is 128bytes')),r(e,i,32,"center"),e.logCenter(e.makeBorder("Verification")),o===i.slice(0,128)?e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([128,255,128]," => SUCCESS: THE DERIVED KEY FIRST 64 BYTES WERE THE SAME!"))}\n    `):e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([255,128,128]," => FAILURE: THE DERIVED KEY FIRST 64 BYTES WERE NOT THE SAME!"))}\n    `),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("Derive Key Features test"))))})(i),i.logCenter(i.makeColor([255,0,0],"\n\nSTOP\n\n"))};
