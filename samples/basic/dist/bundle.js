"use strict";class e{_parentElement;constructor(e){this._parentElement=e,this._clear()}makeBorder(e){return`<span style="padding: 10px; margin: 10px; border: 3px solid; border-color: rgb(64, 64, 64); line-height: 5.8;">${e}</span>`}makeColor(e,t){return`<span style="color: rgb(${e[0]}, ${e[1]}, ${e[2]});">${t}</span>`}makeSize(e,t){return`<span style="font-size: ${e}px;">${t}</span>`}alignedLog(e,...t){const r=t.join(" ").split("\n").join("<br>")+"<br>",a=document.createElement("p");a.innerHTML=r,a.style=`text-align: ${e};`,this._parentElement.appendChild(a)}log(...e){this.alignedLog.apply(this,["left",...e])}logLeft(...e){this.alignedLog.apply(this,["left",...e])}logRight(...e){this.alignedLog.apply(this,["right",...e])}logCenter(...e){this.alignedLog.apply(this,["center",...e])}error(...e){this.alignedLog.apply(this,["center","ERR",...e])}_clear(){for(;this._parentElement.firstChild;)this._parentElement.removeChild(this._parentElement.lastChild)}}class t{static _wasmModule;static async load(){var e;await(e="../../build/wasm-cryptopp.js",new Promise(((t,r)=>{const a=document.createElement("script");a.src=e,a.addEventListener("load",t),a.addEventListener("error",r),document.head.appendChild(a)}))),await t.rawLoad()}static async rawLoad(){t._wasmModule=await wasmCryptoppJs({locateFile:e=>(console.log(`url: "${e}"`),`../../build/${e}`)})}static get(){if(!this._wasmModule)throw new Error("crytpopp wasm module not loaded");return this._wasmModule}}const r=(e,t,r,a)=>{const o=t.length.toString();let i=0;for(;i<t.length;){let n=t.substr(i,r);i>0&&(n=n.padEnd(r,"_"));const l=e.makeColor([128,128,64],n);switch(a){case"left":e.alignedLog(a,` => {${i.toString().padStart(3,"_")} / ${o}} ${l}`);break;case"right":e.alignedLog(a,`${l} {${i.toString().padStart(3,"_")} / ${o}} <= `);break;case"center":e.alignedLog(a,`${l}`)}i+=r}},a=async(e,t)=>{const r=Date.now(),a=await e();return t(Date.now()-r),a};window.onload=async()=>{const o=(e=>{const t=document.querySelector(e);if(!t)throw new Error(`DOM elements not found, id: "${e}"`);return t})("#loggerOutput"),i=new e(o);i.logCenter(i.makeColor([255,0,0],"\n\nSTART\n\n")),i.logCenter("page loaded"),i.logCenter(" loading wasmCryptoppJs wasm script");const n=Date.now();await t.load();const l=Date.now()-n;i.logCenter(`wasmCryptoppJs wasm module loaded ${l}ms`),await(async e=>{const o=t.get();e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("AesSymmetricCipher test"))));const i=new o.AutoSeededRandomPoolJs;e.alignedLog("center","generate random key value");const n=i.getRandomHexStr(32);e.alignedLog("center","generate random iv value");const l=i.getRandomHexStr(16);i.delete(),e.logCenter(e.makeBorder("AesSymmetricCipher A: initialize")),e.alignedLog("left","create the AES Symmetric Cipher A");const g=new o.AesSymmetricCipherJs;e.alignedLog("left","initialize the AES Symmetric Cipher A"),e.alignedLog("left","initializing"),await a((()=>{g.initializeFromHexStr(n,l)}),(t=>{e.alignedLog("left",`initialized (${t}ms)`)})),e.logCenter(e.makeBorder("AesSymmetricCipher B: initialize")),e.alignedLog("right","create the AES Symmetric Cipher B");const d=new o.AesSymmetricCipherJs;e.alignedLog("right","initialize the AES Symmetric Cipher B"),e.alignedLog("right","initializing"),await a((()=>{d.initializeFromHexStr(n,l)}),(t=>{e.alignedLog("right",`initialized (${t}ms)`)})),e.logCenter(e.makeBorder("AesSymmetricCipher A: encrypt payload"));const s="This is my plain text message....";e.alignedLog("left",`original payload:  "${e.makeColor([64,192,64],s)}"`);const m=o.utf8ToHex(s);e.alignedLog("left","encrypting");const c=await a((()=>g.encryptFromHexStrAsHexStr(m)),(t=>{e.alignedLog("left",`encrypted (${t}ms)`)}));e.alignedLog("left","encrypted payload:"),r(e,c,32,"left"),e.logCenter(e.makeBorder("AesSymmetricCipher B: decrypt payload")),e.alignedLog("right","encrypted payload:"),r(e,c,32,"right"),e.alignedLog("right","decrypting");const p=await a((()=>g.decryptFromHexStrAsHexStr(c)),(t=>{e.alignedLog("right",`decrypted (${t}ms)`)})),y=o.hexToUtf8(p);e.alignedLog("right",`decrypted payload: "${e.makeColor([128,128,255],y)}"`),e.alignedLog("right",`original payload:  "${e.makeColor([64,192,64],s)}"`),e.logCenter(e.makeBorder("Verification")),y===s?e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([128,255,128]," => SUCCESS: ENCRYPTED PAYLOAD WAS RECOVERED!"))}\n    `):e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([255,128,128]," => FAILURE: ENCRYPTED PAYLOAD WAS NOT RECOVERED!"))}\n    `),g.delete(),d.delete(),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("AesSymmetricCipher test"))))})(i),await(async e=>{const o=t.get();e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("DiffieHellmanClient test"))));const i=e.makeColor([192,128,128],"Client A"),n=e.makeColor([128,128,192],"Client B");e.logCenter(e.makeBorder(`${i} initialize`)),e.logLeft(`${i} created`);const l=new o.DiffieHellmanClientJs;e.logLeft(`${i} generate keys`),e.alignedLog("left","generating"),await a((()=>{l.generateRandomKeysSimpler()}),(t=>{e.alignedLog("left",`generated (${t}ms)`)})),e.logLeft(`${i} provide public key`);const g=l.getPublicKeyAsHexStr();e.logLeft(`${i} public key as hexadecimal value:`),r(e,g,64,"left"),e.log(),e.logCenter(e.makeBorder(`${n} initialize`)),e.logRight(`${n} created`);const d=new o.DiffieHellmanClientJs;e.logRight(`${n} generate keys`),e.alignedLog("right","generating"),await a((()=>{d.generateRandomKeysSimpler()}),(t=>{e.alignedLog("right",`generated (${t}ms)`)})),e.logRight(`${n} provide public key`);const s=d.getPublicKeyAsHexStr();e.logRight(`${n} public key as hexadecimal value:`),r(e,s,64,"right"),e.log(),e.logCenter(e.makeBorder(`${i} compute shared secret (with ${n} public key)`)),e.alignedLog("left","computing");const m=await a((()=>(l.computeSharedSecretFromHexStr(s),l.getSharedSecretAsHexStr())),(t=>{e.alignedLog("left",`computed (${t}ms)`)}));e.logLeft(`${i} computed shared secret as hexadecimal value:`),r(e,m,64,"left"),e.log(),e.logCenter(e.makeBorder(`${n} compute shared secret (with ${i} public key)`)),e.alignedLog("right","computing");const c=await a((()=>(d.computeSharedSecretFromHexStr(g),d.getSharedSecretAsHexStr())),(t=>{e.alignedLog("right",`computed (${t}ms)`)}));e.logRight(`${n} computed shared secret as hexadecimal value:`),r(e,c,64,"right"),e.log(),e.logCenter(e.makeBorder("verification")),m==c?e.logCenter(`\n      ${e.makeBorder(e.makeColor([128,255,128]," => SUCCESS: BOTH CLIENTS SHARE THE SAME SECRET!"))}\n    `):e.logCenter(`\n      ${e.makeBorder(e.makeColor([255,128,128]," => FAILURE: CLIENTS SECRETS ARE NOT MATCHING!"))}\n    `),l.delete(),d.delete(),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("DiffieHellmanClient test"))))})(i),await(async e=>{const o=t.get();e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("RSA Features test")))),e.logCenter(e.makeBorder("RSA Features: setup"));const i=new o.AutoSeededRandomPoolJs,n={privateKey:new o.RSAPrivateKeyJs,publicKey:new o.RSAPublicKeyJs},l={privateKey:new o.RSAPrivateKeyJs,publicKey:new o.RSAPublicKeyJs};e.logCenter(e.makeBorder("RSA Features: initialize")),e.alignedLog("center","generate random private key of 3072 bytes (PRIVATE KEY A)"),e.alignedLog("center","generating"),await a((()=>{n.privateKey.generateRandomWithKeySizeUsingAutoSeeded(i,3072)}),(t=>{e.alignedLog("center",`generated (${t}ms)`)})),e.alignedLog("left",n.privateKey.getAsPemString()),e.alignedLog("center","get public key from the private key (PUBLIC KEY A)"),n.publicKey.setFromPrivateKey(n.privateKey),e.alignedLog("left",n.publicKey.getAsPemString()),e.logCenter(e.makeBorder("RSA Features: PEM GET/LOAD")),e.alignedLog("center","load a new private key (PRIVATE KEY B) from the PEM of the first private key (PRIVATE KEY A)"),l.privateKey.loadFromPemString(n.privateKey.getAsPemString()),e.alignedLog("center","load a new public key (PUBLIC KEY B) from the PEM of the first public key (PUBLIC KEY A)"),l.publicKey.loadFromPemString(n.publicKey.getAsPemString()),e.logCenter(e.makeBorder("RSA Features: SIGN")),e.alignedLog("center","sign some content with the second private key (PRIVATE KEY B)");const g="Hello from JavaScript!";e.alignedLog("center","original payload:"),e.logCenter(e.makeColor([0,128,0],e.makeSize(30,`"${g}"`)));const d=o.utf8ToHex(g);e.alignedLog("center","signing");const s=await a((()=>l.privateKey.signFromHexStrToHexStrUsingAutoSeeded(i,d)),(t=>{e.alignedLog("center",`signed (${t}ms)`)}));e.alignedLog("center","signed payload:"),r(e,s,64,"center"),e.logCenter(e.makeBorder("RSA Features: VERIFY")),e.alignedLog("center","verify signed content with the first public key (PUBLIC KEY A)"),e.alignedLog("center","verifying");const m=await a((()=>n.publicKey.verifyFromHexStrToHexStr(s)),(t=>{e.alignedLog("center",`verified (${t}ms)`)})),c=o.hexToUtf8(m);e.alignedLog("center","verified payload:"),e.logCenter(e.makeColor([0,128,0],e.makeSize(30,`"${c}"`))),e.logCenter(e.makeBorder("Verification")),c===g?e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([128,255,128]," => SUCCESS: SIGNED PAYLOAD WAS VERIFIED!"))}\n    `):e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([255,128,128]," => FAILURE: SIGNED PAYLOAD WAS NOT VERIFIED!"))}\n    `),l.publicKey.delete(),l.privateKey.delete(),n.publicKey.delete(),n.privateKey.delete(),i.delete(),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("RSA Features test"))))})(i),await(async e=>{const a=t.get();e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("Derive Key Features test"))));const o=a.deriveSha256HexStrKeyFromHexStrData(a.utf8ToHex("my password"),a.utf8ToHex("my salt"),a.utf8ToHex("my info"),64);e.logCenter(e.makeBorder('Derive key A, password is "my password", size is 64bytes')),r(e,o,32,"center");const i=a.deriveSha256HexStrKeyFromHexStrData(a.utf8ToHex("my password"),a.utf8ToHex("my salt"),a.utf8ToHex("my info"),128);e.logCenter(e.makeBorder('Derive key B, password is "my password", size is 128bytes')),r(e,i,32,"center"),e.logCenter(e.makeBorder("Verification")),o===i.slice(0,128)?e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([128,255,128]," => SUCCESS: THE DERIVED KEY FIRST 64 BYTES WERE THE SAME!"))}\n    `):e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([255,128,128]," => FAILURE: THE DERIVED KEY FIRST 64 BYTES WERE NOT THE SAME!"))}\n    `),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("Derive Key Features test"))))})(i),i.logCenter(i.makeColor([255,0,0],"\n\nSTOP\n\n"))};
