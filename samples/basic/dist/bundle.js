"use strict";class e{_parentElement;constructor(e){this._parentElement=e,this._clear()}makeBorder(e){return`<span style="padding: 10px; margin: 10px; border: 3px solid; border-color: rgb(64, 64, 64); line-height: 5.8;">${e}</span>`}makeColor(e,t){return`<span style="color: rgb(${e[0]}, ${e[1]}, ${e[2]});">${t}</span>`}makeSize(e,t){return`<span style="font-size: ${e}px;">${t}</span>`}alignedLog(e,...t){const r=t.join(" ").split("\n").join("<br>")+"<br>",o=document.createElement("p");o.innerHTML=r,o.style=`text-align: ${e};`,this._parentElement.appendChild(o)}log(...e){this.alignedLog.apply(this,["left",...e])}logLeft(...e){this.alignedLog.apply(this,["left",...e])}logRight(...e){this.alignedLog.apply(this,["right",...e])}logCenter(...e){this.alignedLog.apply(this,["center",...e])}error(...e){this.alignedLog.apply(this,["center","ERR",...e])}_clear(){for(;this._parentElement.firstChild;)this._parentElement.removeChild(this._parentElement.lastChild)}}class t{static _wasmModule;static async load(){var e;await(e="../../build/wasm-cryptopp.js",new Promise(((t,r)=>{const o=document.createElement("script");o.src=e,o.addEventListener("load",t),o.addEventListener("error",r),document.head.appendChild(o)}))),t._wasmModule=await wasmCryptoppJs()}static get(){if(!this._wasmModule)throw new Error("crytpopp wasm module not loaded");return this._wasmModule}}const r=(e,t,r,o)=>{const a=t.length.toString();let n=0;for(;n<t.length;){let i=t.substr(n,r);n>0&&(i=i.padEnd(r,"_"));const l=e.makeColor([128,128,64],i);switch(o){case"left":e.alignedLog(o,` => {${n.toString().padStart(3,"_")} / ${a}} ${l}`);break;case"right":e.alignedLog(o,`${l} {${n.toString().padStart(3,"_")} / ${a}} <= `);break;case"center":e.alignedLog(o,`${l}`)}n+=r}};window.onload=async()=>{const o=(e=>{const t=document.querySelector(e);if(!t)throw new Error(`DOM elements not found, id: "${e}"`);return t})("#loggerOutput"),a=new e(o);a.logCenter(a.makeColor([255,0,0],"\n\nSTART\n\n")),a.logCenter("page loaded"),a.logCenter(" loading wasmCryptoppJs wasm script"),await t.load(),a.logCenter("wasmCryptoppJs wasm module loaded"),(e=>{const o=t.get();e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("AesSymmetricCipher test"))));const a=new o.AutoSeededRandomPoolJs;e.alignedLog("center","generate random key value");const n=a.getRandomHexStr(32);e.alignedLog("center","generate random iv value");const i=a.getRandomHexStr(16);a.delete(),e.logCenter(e.makeBorder("AesSymmetricCipher A: initialize")),e.alignedLog("left","create the AES Symmetric Cipher A");const l=new o.AesSymmetricCipherJs;e.alignedLog("left","initialize the AES Symmetric Cipher A"),l.initializeFromHexStr(n,i),e.logCenter(e.makeBorder("AesSymmetricCipher B: initialize")),e.alignedLog("right","create the AES Symmetric Cipher B");const s=new o.AesSymmetricCipherJs;e.alignedLog("right","initialize the AES Symmetric Cipher B"),s.initializeFromHexStr(n,i),e.logCenter(e.makeBorder("AesSymmetricCipher A: encrypt payload"));const C="This is my plain text message....";e.alignedLog("left",`original payload:  "${e.makeColor([64,192,64],C)}"`);const d=o.utf8ToHex(C),g=l.encryptFromHexStrAsHexStr(d);e.alignedLog("left","encrypted payload:"),r(e,g,32,"left"),e.logCenter(e.makeBorder("AesSymmetricCipher B: decrypt payload")),e.alignedLog("right","encrypted payload:"),r(e,g,32,"right");const m=s.decryptFromHexStrAsHexStr(g),B=o.hexToUtf8(m);e.alignedLog("right",`decrypted payload: "${e.makeColor([128,128,255],B)}"`),e.alignedLog("right",`original payload:  "${e.makeColor([64,192,64],C)}"`),e.logCenter(e.makeBorder("Verification")),B===C?e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([128,255,128]," => SUCCESS: ENCRYPTED PAYLOAD WAS RECOVERED!"))}\n    `):e.alignedLog("center",`\n      ${e.makeBorder(e.makeColor([255,128,128]," => FAILURE: ENCRYPTED PAYLOAD WAS NOT RECOVERED!"))}\n    `),l.delete(),s.delete(),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("AesSymmetricCipher test"))))})(a),(e=>{const o=t.get();e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("DiffieHellmanClient test"))));const a=e.makeColor([192,128,128],"Client A"),n=e.makeColor([128,128,192],"Client B"),i=["0x87A8E61DB4B6663CFFBBD19C651959998CEEF608660DD0F2","5D2CEED4435E3B00E00DF8F1D61957D4FAF7DF4561B2AA30","16C3D91134096FAA3BF4296D830E9A7C209E0C6497517ABD","5A8A9D306BCF67ED91F9E6725B4758C022E0B1EF4275BF7B","6C5BFC11D45F9088B941F54EB1E59BB8BC39A0BF12307F5C","4FDB70C581B23F76B63ACAE1CAA6B7902D52526735488A0E","F13C6D9A51BFA4AB3AD8347796524D8EF6A167B5A41825D9","67E144E5140564251CCACB83E6B486F6B3CA3F7971506026","C0B857F689962856DED4010ABD0BE621C3A3960A54E710C3","75F26375D7014103A4B54330C198AF126116D2276E11715F","693877FAD7EF09CADB094AE91E1A1597"].join(""),l="0x8CF83642A709A097B447997640129DA299B1A47D1EB3750BA308B0FE64F5FBD3",s=["0x3FB32C9B73134D0B2E77506660EDBD484CA7B18F21EF2054","07F4793A1A0BA12510DBC15077BE463FFF4FED4AAC0BB555","BE3A6C1B0C6B47B1BC3773BF7E8C6F62901228F8C28CBB18","A55AE31341000A650196F931C77A57F2DDF463E5E9EC144B","777DE62AAAB8A8628AC376D282D6ED3864E67982428EBC83","1D14348F6F2F9193B5045AF2767164E1DFC967C1FB3F2E55","A4BD1BFFE83B9C80D052B985D182EA0ADB2A3B7313D3FE14","C8484B1E052588B9B7D2BBD2DF016199ECD06E1557CD0915","B3353BBB64E0EC377FD028370DF92B52C7891428CDC67EB6","184B523D1DB246C32F63078490F00EF8D647D148D4795451","5E2327CFEF98C582664B4C0F6CC41659"].join("");e.logCenter(e.makeBorder(`${a} initialize`)),e.logLeft(`${a} created`);const C=new o.DiffieHellmanClientJs;e.logLeft(`${a} generate keys`),C.generateKeys(i,l,s),e.logLeft(`${a} provide public key`);const d=C.getPublicKeyAsHexStr();e.logCenter(e.makeBorder(`${n} initialize`)),e.logRight(`${n} created`);const g=new o.DiffieHellmanClientJs;e.logRight(`${n} generate keys`),g.generateKeys(i,l,s),e.logRight(`${n} provide public key`);const m=g.getPublicKeyAsHexStr();e.logCenter(e.makeBorder(`${a} compute shared secret (with ${n} public key)`)),C.computeSharedSecretFromHexStr(m);const B=C.getSharedSecretAsHexStr();e.logLeft(`${a} computed shared secret as hexadecimal value:`),r(e,B,64,"left"),e.log(),e.logCenter(e.makeBorder(`${n} compute shared secret (with ${a} public key)`)),g.computeSharedSecretFromHexStr(d);const c=g.getSharedSecretAsHexStr();e.logRight(`${n} computed shared secret as hexadecimal value:`),r(e,c,64,"right"),e.log(),e.logCenter(e.makeBorder("verification")),B==c?e.logCenter(`\n      ${e.makeBorder(e.makeColor([128,255,128]," => SUCCESS: BOTH CLIENTS SHARE THE SAME SECRET!"))}\n    `):e.logCenter(`\n      ${e.makeBorder(e.makeColor([255,128,128]," => FAILURE: CLIENTS SECRETS ARE NOT MATCHING!"))}\n    `),C.delete(),g.delete(),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("DiffieHellmanClient test"))))})(a),a.logCenter(a.makeColor([255,0,0],"\n\nSTOP\n\n"))};
