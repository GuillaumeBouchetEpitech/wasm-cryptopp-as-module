"use strict";class e{_parentElement;constructor(e){this._parentElement=e,this._clear()}makeBorder(e){return`<span style="padding: 10px; margin: 10px; border: 3px solid; border-color: rgb(64, 64, 64); line-height: 5.8;">${e}</span>`}makeColor(e,t){return`<span style="color: rgb(${e[0]}, ${e[1]}, ${e[2]});">${t}</span>`}makeSize(e,t){return`<span style="font-size: ${e}px;">${t}</span>`}alignedLog(e,...t){const r=t.join(" ").split("\n").join("<br>")+"<br>",s=document.createElement("p");s.innerHTML=r,s.style=`text-align: ${e};`,this._parentElement.appendChild(s)}log(...e){this.alignedLog.apply(this,["left",...e])}logLeft(...e){this.alignedLog.apply(this,["left",...e])}logRight(...e){this.alignedLog.apply(this,["right",...e])}logCenter(...e){this.alignedLog.apply(this,["center",...e])}error(...e){this.alignedLog.apply(this,["center","ERR",...e])}_clear(){for(;this._parentElement.firstChild;)this._parentElement.removeChild(this._parentElement.lastChild)}}class t{static _wasmModule;static async load(){var e;await(e="../../build/wasm-cryptopp.js",new Promise(((t,r)=>{const s=document.createElement("script");s.src=e,s.addEventListener("load",t),s.addEventListener("error",r),document.head.appendChild(s)}))),await t.rawLoad()}static async rawLoad(){t._wasmModule=await wasmCryptoppJs({locateFile:e=>(console.log(`url: "${e}"`),`../../build/${e}`)})}static get(){if(!this._wasmModule)throw new Error("crytpopp wasm module not loaded");return this._wasmModule}}var r;!function(e){e.initialize="initialize",e.create_secure_context="create_secure_context",e.derive_rsa_keys="derive_rsa_keys"}(r||(r={}));const s=async(e,t)=>(e.postMessage(t),await(async e=>new Promise(((t,r)=>{const s=r=>{e.removeEventListener("message",s),t(r.data)};try{e.addEventListener("message",s)}catch(t){try{e.removeEventListener("message",s)}catch(e){}r(t)}})))(e));class o{_workerInstance;_secureContextId;_privateKeyPem;_publicKeyPem;constructor(){}async initialize(){if(!this._workerInstance){{this._workerInstance=new Worker("./dist/worker-derive-rsa-key.js");const e=await(async e=>s(e,{type:r.initialize}))(this._workerInstance);console.log("message.success",e.success),console.log("message.response",e.response)}{const e=await(async e=>s(e,{type:r.create_secure_context}))(this._workerInstance);console.log("message.success",e.success),console.log("message.response",e.response),this._secureContextId=e.response.id}}}async dispose(){this._workerInstance&&(this._workerInstance.terminate(),this._workerInstance=void 0,this._secureContextId=void 0,this._privateKeyPem=void 0,this._publicKeyPem=void 0)}async deriveRsaKeys(e,t){if(!this._workerInstance)throw new Error("worker not initialized");if(!this._secureContextId)throw new Error("secure context not initialized");const o=await(async(e,t,o,a)=>s(e,{type:r.derive_rsa_keys,id:t,password:o,keySize:a}))(this._workerInstance,this._secureContextId,e,t);if("object"==typeof(a=o)&&!1===a.success&&"object"==typeof a.response)throw new Error(o.response.error);var a;return this._privateKeyPem=o.response.privateKeyPem,this._publicKeyPem=o.response.publicKeyPem,o.response.elapsedTime}makeRsaKeyPair(){if(!this._privateKeyPem)throw new Error("no public key derived");if(!this._publicKeyPem)throw new Error("no public key derived");return new a(this._privateKeyPem,this._publicKeyPem)}get privateKeyPem(){return this._privateKeyPem}get publicKeyPem(){return this._publicKeyPem}}class a{_privateKey;_publicKey;_prng;constructor(e,r){const s=t.get();this._prng=new s.AutoSeededRandomPoolJs,this._privateKey=new s.RSAPrivateKeyJs,this._publicKey=new s.RSAPublicKeyJs,this._privateKey.loadFromPemString(e),this._publicKey.loadFromPemString(r)}signPayloadToHexStr(e){const r=t.get().utf8ToHex(e);return this._privateKey.signFromHexStrToHexStrUsingAutoSeeded(this._prng,r)}verifyHexStrPayloadToStr(e){const r=t.get();try{const t=this._publicKey.verifyFromHexStrToHexStr(e);return r.hexToUtf8(t)}catch(e){if("number"==typeof e)throw new Error(r.getExceptionMessage(e));throw e}}}window.onload=async()=>{const r=Date.now(),s=(e=>{const t=document.querySelector(e);if(!t)throw new Error(`DOM elements not found, id: "${e}"`);return t})("#loggerOutput"),a=new e(s);a.logCenter("page loaded"),a.logCenter(a.makeColor([255,0,0],"\n\nSTART\n\n")),a.logCenter(" loading worker-obtain-cipher-key"),a.logCenter(" loading worker-symmetric-cipher");const n=Date.now();await t.load();const i=Date.now();a.logCenter(`wasmCryptoppJs wasm module loaded (${i-n}ms)`),await(async e=>{e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("Derive RSA Keys from password")))),t.get();const r=new o;await r.initialize();const s=1024;e.logCenter(e.makeBorder('Test1, Password: "pineapple", Key Size: 1024'));let a=await r.deriveRsaKeys("pineapple",s);e.logCenter(r.privateKeyPem),e.logCenter(r.publicKeyPem),e.logCenter(e.makeBorder(`Test1 elapsedTime: ${a}ms`));const n=r.makeRsaKeyPair();e.logCenter(e.makeBorder('Test2, Password: "pen", Key Size: 1024')),a=await r.deriveRsaKeys("pen",s),e.logCenter(r.privateKeyPem),e.logCenter(r.publicKeyPem),e.logCenter(e.makeBorder(`Test2 elapsedTime: ${a}ms`));const i=r.makeRsaKeyPair();e.logCenter(e.makeBorder('Test3, Password: "pineapple", Key Size: 1024')),a=await r.deriveRsaKeys("pineapple",s),e.logCenter(r.privateKeyPem),e.logCenter(r.publicKeyPem),e.logCenter(e.makeBorder(`Test3 elapsedTime: ${a}ms`));const l=r.makeRsaKeyPair();e.logCenter(e.makeBorder("Sign payload with Test1 private key"));const c=n.signPayloadToHexStr("LOL");e.logCenter('\npayload: "LOL"'),e.logCenter("\nsignedPayload"),((e,t,r,s)=>{const o=t.length.toString();let a=0;for(;a<t.length;){let n=t.substr(a,r);a>0&&(n=n.padEnd(r,"_"));const i=e.makeColor([128,128,64],n);switch(s){case"left":e.alignedLog(s,` => {${a.toString().padStart(3,"_")} / ${o}} ${i}`);break;case"right":e.alignedLog(s,`${i} {${a.toString().padStart(3,"_")} / ${o}} <= `);break;case"center":e.alignedLog(s,`${i}`)}a+=r}})(e,c,64,"center"),e.logCenter(e.makeBorder("Verify payload with Test3 public key (NOT the same password)"));try{const t=i.verifyHexStrPayloadToStr(c);e.logCenter(`\nverifiedPayload: "${t}"`)}catch(t){e.logCenter(`\nverifiedPayload ERROR: "${t?.message}"`)}e.logCenter(e.makeBorder("Verify payload with Test3 public key (WITH the same password)"));const d=l.verifyHexStrPayloadToStr(c);e.logCenter(`\nverifiedPayload: "${d}"`),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("Derive RSA Keys from password"))))})(a);const l=Date.now();a.logCenter(a.makeColor([255,0,0],`\n\nSTOP (${l-r}ms)\n\n`))};
