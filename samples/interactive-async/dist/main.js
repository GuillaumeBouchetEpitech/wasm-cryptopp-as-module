"use strict";class e{_parentElement;constructor(e){this._parentElement=e,this._clear()}makeBorder(e){return`<span style="padding: 10px; margin: 10px; border: 3px solid; border-color: rgb(64, 64, 64); line-height: 5.8;">${e}</span>`}makeColor(e,t){return`<span style="color: rgb(${e[0]}, ${e[1]}, ${e[2]});">${t}</span>`}makeSize(e,t){return`<span style="font-size: ${e}px;">${t}</span>`}alignedLog(e,...t){const i=t.join(" ").split("\n").join("<br>")+"<br>",s=document.createElement("p");s.innerHTML=i,s.style=`text-align: ${e};`,this._parentElement.appendChild(s)}log(...e){this.alignedLog.apply(this,["left",...e])}logLeft(...e){this.alignedLog.apply(this,["left",...e])}logRight(...e){this.alignedLog.apply(this,["right",...e])}logCenter(...e){this.alignedLog.apply(this,["center",...e])}error(...e){this.alignedLog.apply(this,["center","ERR",...e])}_clear(){for(;this._parentElement.firstChild;)this._parentElement.removeChild(this._parentElement.lastChild)}}class t{static _wasmModule;static async load(){var e;await(e="../../build/wasm-cryptopp.js",new Promise(((t,i)=>{const s=document.createElement("script");s.src=e,s.addEventListener("load",t),s.addEventListener("error",i),document.head.appendChild(s)}))),await t.rawLoad()}static async rawLoad(){t._wasmModule=await wasmCryptoppJs({locateFile:e=>(console.log(`url: "${e}"`),`../../build/${e}`)})}static get(){if(!this._wasmModule)throw new Error("crytpopp wasm module not loaded");return this._wasmModule}}const i=(e,t,i,s)=>{const n=t.length.toString();let r=0;for(;r<t.length;){let a=t.substr(r,i);r>0&&(a=a.padEnd(i,"_"));const o=e.makeColor([128,128,64],a);switch(s){case"left":e.alignedLog(s,` => {${r.toString().padStart(3,"_")} / ${n}} ${o}`);break;case"right":e.alignedLog(s,`${o} {${r.toString().padStart(3,"_")} / ${n}} <= `);break;case"center":e.alignedLog(s,`${o}`)}r+=i}};var s;!function(e){e.initialize="initialize",e.create_secure_context="create_secure_context",e.generate_diffie_hellman_keys="generate_diffie_hellman_keys",e.compute_diffie_hellman_shared_secret="compute_diffie_hellman_shared_secret"}(s||(s={}));const n=async(e,t)=>(e.postMessage(t),await(async e=>new Promise(((t,i)=>{const s=i=>{e.removeEventListener("message",s),t(i.data)};try{e.addEventListener("message",s)}catch(t){try{e.removeEventListener("message",s)}catch(e){}i(t)}})))(e)),r=e=>"object"==typeof e&&!1===e.success&&"object"==typeof e.response;class a{_workerInstance;_secureContextId;_publicKey;_sharedSecret;constructor(){}async initialize(){if(!this._workerInstance){{this._workerInstance=new Worker("./dist/worker-diffie-hellman.js");const e=await(async e=>n(e,{type:s.initialize}))(this._workerInstance);console.log("message.success",e.success),console.log("message.response",e.response)}{const e=await(async e=>n(e,{type:s.create_secure_context}))(this._workerInstance);console.log("message.success",e.success),console.log("message.response",e.response),this._secureContextId=e.response.id}}}async dispose(){this._workerInstance&&(this._workerInstance.terminate(),this._workerInstance=void 0,this._secureContextId=void 0,this._publicKey=void 0,this._sharedSecret=void 0)}async generateDiffieHellmanKeys(){if(!this._workerInstance)throw new Error("worker not initialized");if(!this._secureContextId)throw new Error("secure context not initialized");const e=await(async(e,t)=>n(e,{type:s.generate_diffie_hellman_keys,id:t}))(this._workerInstance,this._secureContextId);if(r(e))throw new Error(e.response.error);this._publicKey=e.response.publicKey}async computeDiffieHellmanSharedSecret(e){if(!this._workerInstance)throw new Error("worker not initialized");if(!this._secureContextId)throw new Error("secure context not initialized");const t=await(async(e,t,i)=>n(e,{type:s.compute_diffie_hellman_shared_secret,id:t,publicKey:i}))(this._workerInstance,this._secureContextId,e);if(r(t))throw new Error(t.response.error);this._sharedSecret=t.response.sharedSecret}get publicKey(){return this._publicKey}get sharedSecret(){return this._sharedSecret}}var o;!function(e){e.PlainMessage="PlainMessage",e.EncryptedMessage="EncryptedMessage",e.SecurityRequest="SecurityRequest",e.SecurityResponse="SecurityResponse"}(o||(o={}));const l=e=>"object"==typeof e&&"string"==typeof e.type&&"string"==typeof e.payload;var c;!function(e){e[e.unencrypted=0]="unencrypted",e[e.initiated=1]="initiated",e[e.ready=2]="ready",e[e.confirmed=3]="confirmed"}(c||(c={}));const g=e=>"object"==typeof e&&"string"==typeof e.publicKey,h=e=>g(e)&&"string"==typeof e.ivValue,d=(e,t,i)=>{const s=t.length.toString();let n=0;for(;n<t.length;){let r=t.substr(n,i);n>0&&(r=r.padEnd(i,"_")),e(` => {${n.toString().padStart(3,"_")} / ${s}} ${r}`),n+=i}};class p{_wasDeleted=!1;_communication;_EncryptedCommunicationState=c.unencrypted;_onReceiveCallbacks=[];_onLogging;_workerObtainCipherKey;_publicKey;_ivValue;_sharedSecret;_aesSymmetricCipher;constructor(e,i){this._communication=e,this._onLogging=i;const s=t.get();this._aesSymmetricCipher=new s.AesSymmetricCipherJs,this._communication.onReceive((async e=>{await this._processReceivedMessage(e)}))}async initialize(){await this._initializeDiffieHellmanWorker()}delete(){this._aesSymmetricCipher.delete(),this._workerObtainCipherKey?.dispose(),this._wasDeleted=!0}async makeSecure(){if(this._wasDeleted)throw new Error("was deleted");if(!this._workerObtainCipherKey)throw new Error("worker not initialized");this._log("now securing the connection"),this._EncryptedCommunicationState=c.initiated,await this._generateDiffieHellmanKeys(),this._ivValue=(e=>{const i=new(t.get().AutoSeededRandomPoolJs),s=i.getRandomHexStr(e);return i.delete(),s})(16),this._log("message.response.ivValue"),d(this._log.bind(this),this._ivValue,64);const e=JSON.stringify({publicKey:this._publicKey,ivValue:this._ivValue});this._communication.send(JSON.stringify({type:o.SecurityRequest,payload:e}))}send(e){if(this._wasDeleted)throw new Error("was deleted");if(this._EncryptedCommunicationState===c.initiated)throw new Error("cannot send while securing the connection");if(this._EncryptedCommunicationState===c.unencrypted)this._log("sending a message:","[unencrypted]"),this._log(`"${e}"`,"[unencrypted]"),this._communication.send(JSON.stringify({type:o.PlainMessage,payload:e}));else{this._log("sending a message:","[encrypted]"),this._log(`"${e}"`,"[encrypted]"),this._log("encrypting","[encrypted]");const i=Date.now(),s=t.get().utf8ToHex(e),n=this._aesSymmetricCipher.encryptFromHexStrAsHexStr(s),r=Date.now();this._log(`encrypted (${r-i}ms)`,"[encrypted]"),this._communication.send(JSON.stringify({type:o.EncryptedMessage,payload:n}))}}onReceive(e){if(this._wasDeleted)throw new Error("was deleted");this._onReceiveCallbacks.push(e)}get EncryptedCommunicationState(){if(this._wasDeleted)throw new Error("was deleted");return this._EncryptedCommunicationState}async _initializeDiffieHellmanWorker(){this._workerObtainCipherKey=new a,await this._workerObtainCipherKey.initialize()}async _processReceivedMessage(e){if(this._wasDeleted)throw new Error("was deleted");const i=JSON.parse(e);if(!l(i))throw new Error("received message structure unrecognized");switch(this._log(`received message, type: "${i.type}"`),i.type){case o.PlainMessage:this._onReceiveCallbacks.forEach((e=>e(i.payload)));break;case o.EncryptedMessage:{this._log("decrypting");const e=Date.now(),s=this._aesSymmetricCipher.decryptFromHexStrAsHexStr(i.payload),n=t.get().hexToUtf8(s),r=Date.now();if(this._log(`decrypted (${r-e}ms)`),this._EncryptedCommunicationState===c.ready)this._log("connection now confirmed secure"),this._EncryptedCommunicationState=c.confirmed;else if(this._EncryptedCommunicationState!==c.confirmed)throw new Error("was expecting to be in a secure state");this._onReceiveCallbacks.forEach((e=>e(n)));break}case o.SecurityRequest:{this._log("now securing the connection"),this._EncryptedCommunicationState=c.initiated;const e=JSON.parse(i.payload);if(!h(e))throw new Error("received message security request payload unrecognized");this._ivValue=e.ivValue,await this._generateDiffieHellmanKeys(),await this._computeDiffieHellmanSharedSecret(e.publicKey),await this._initializeAesSymmetricCipher(),this._log("sending public key"),this._EncryptedCommunicationState=c.ready;const t=JSON.stringify({publicKey:this._publicKey});this._communication.send(JSON.stringify({type:o.SecurityResponse,payload:t}));break}case o.SecurityResponse:{if(this._log("processing received security response"),this._EncryptedCommunicationState!==c.initiated)throw new Error("was expecting a security response");this._log("computing the shared secret with the received public key");const e=JSON.parse(i.payload);if(!g(e))throw new Error("received message security response payload unrecognized");await this._computeDiffieHellmanSharedSecret(e.publicKey),await this._initializeAesSymmetricCipher(),this._log("connection now confirmed secure"),this._EncryptedCommunicationState=c.ready;break}default:throw new Error(`received message type unsupported, type: "${i.type}"`)}}_log(e,t){this._onLogging&&this._onLogging(e,t)}async _generateDiffieHellmanKeys(){if(this._log("------------------------------------"),this._log("Diffie Hellman Key Exchange"),this._log("generating public/private keys"),this._log("2048-bit MODP Group with 256-bit Prime Order Subgroup"),!this._workerObtainCipherKey)throw new Error("worker not initialized");await this._workerObtainCipherKey.generateDiffieHellmanKeys(),this._publicKey=this._workerObtainCipherKey.publicKey,this._log("this._publicKey"),d(this._log.bind(this),this._publicKey,64),this._log("------------------------------------")}async _computeDiffieHellmanSharedSecret(e){if(!this._workerObtainCipherKey)throw new Error("worker not initialized");this._log("input publicKey"),d(this._log.bind(this),e,64),await this._workerObtainCipherKey.computeDiffieHellmanSharedSecret(e),this._sharedSecret=this._workerObtainCipherKey.sharedSecret,this._log("this._sharedSecret"),d(this._log.bind(this),this._sharedSecret,64)}async _initializeAesSymmetricCipher(){if(!this._ivValue)throw new Error("iv value not initialized");if(!this._sharedSecret)throw new Error("shared secret not initialized");if(!this._workerObtainCipherKey)throw new Error("worker not initialized");this._log("------------------------------------"),this._log("AES Symmetric Cipher"),this._log("initializing"),this._log("256bits key from computed shared secret");const e=Date.now();this._aesSymmetricCipher.initializeFromHexStr(this._sharedSecret.slice(0,64),this._ivValue);const t=Date.now();this._log(`initialized (${t-e}ms)`),this._log("------------------------------------")}}const y=["/!\\","UNENCRYPTED MESSAGE","ANYONE LISTENING CAN SEE IT","/!\\"].join("\n"),_=["(OK)","ENCRYPTED MESSAGE","GOOD LUCK TO ANYONE LISTENING","(OK)"].join("\n"),m=["(OK)","NO COMPROMISING INFORMATION SHARED","GOOD LUCK TO ANYONE LISTENING","(OK)"].join("\n"),w=(e,t,i)=>{i.type===o.PlainMessage?e.alignedLog(t,e.makeColor([128,64,64],y)):i.type===o.EncryptedMessage?e.alignedLog(t,e.makeColor([64,128,64],_)):i.type!==o.SecurityRequest&&i.type!==o.SecurityResponse||e.alignedLog(t,e.makeColor([64,128,64],m))};class u{_logger;_logTextAlign;_myName;_otherName;_transitionStr;_allSentMessages=[];_allOnReceiveCallbacks=[];constructor(e,t,i,s){this._logger=e,this._logTextAlign=t,this._myName=i,this._otherName=s,this._transitionStr="right"===t?"<-----":"-----\x3e"}send(e){this._logger.alignedLog(this._logTextAlign,`fake websocket "${this._myName}" sent a message\n`),this._logger.alignedLog("center",`"${this._myName}" ${this._transitionStr} "${this._otherName}"`),((e,t,s)=>{const n=JSON.parse(s);if(l(n)){if(w(e,t,n),e.alignedLog(t,"type:"),e.alignedLog(t,e.makeColor([192,192,64],`"${n.type}"`)),n.type===o.PlainMessage)e.alignedLog(t,"payload:"),e.alignedLog(t,e.makeColor([192,64,64],e.makeSize(25,`"${n.payload}"`)));else try{const s=JSON.parse(n.payload);h(s)?(e.alignedLog(t,"payload.publicKey:"),i(e,s.publicKey,64,t),e.alignedLog(t,"payload.ivValue:"),i(e,s.ivValue,64,t)):g(s)?(e.alignedLog(t,"payload.publicKey:"),i(e,s.publicKey,64,t)):(e.alignedLog(t,"payload:"),i(e,n.payload,64,t))}catch{e.alignedLog(t,"payload:"),i(e,n.payload,64,t)}w(e,t,n)}else e.alignedLog(t,`"${s}"`)})(this._logger,"center",e),this._logger.alignedLog("center",`"${this._myName}" ${this._transitionStr} "${this._otherName}"`),this._logger.alignedLog("center","\n"),this._allSentMessages.push(e)}async receive(e){this._logger.alignedLog(this._logTextAlign,`fake websocket "${this._myName}" received a message`);for(const t of this._allOnReceiveCallbacks)await t(e)}onReceive(e){this._allOnReceiveCallbacks.push(e)}async pipeMessages(e){for(const t of this._allSentMessages)await e.receive(t);this._allSentMessages.length=0}hasMessageToSend(){return this._allSentMessages.length>0}}window.onload=async()=>{const i=Date.now(),s=(e=>{const t=document.querySelector(e);if(!t)throw new Error(`DOM elements not found, id: "${e}"`);return t})("#loggerOutput"),n=new e(s);n.logCenter("page loaded"),n.logCenter(n.makeColor([255,0,0],"\n\nSTART\n\n")),n.logCenter(" loading worker-obtain-cipher-key"),n.logCenter(" loading worker-symmetric-cipher");const r=Date.now();await t.load();const a=Date.now();n.logCenter(`wasmCryptoppJs wasm module loaded (${a-r}ms)`),await(async e=>{e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("Secure Connection Test"))));const t=e.makeColor([192,128,128],"Client A"),i=e.makeColor([128,128,192],"Client B"),s=new u(e,"left",t,i),n=new u(e,"right",i,t);e.logCenter(e.makeBorder("initialize")),e.logLeft(`${t} created`);const r=new p(s,((t,i)=>{i?e.logLeft(`${i} ${t}`):e.logLeft(t)}));e.logRight(`${i} created`);const a=new p(n,((t,i)=>{i?e.logRight(`${t} ${i}`):e.logRight(t)}));r.onReceive((async i=>{e.alignedLog("left",`${t} received:`),e.alignedLog("left",e.makeColor([64,192,64],e.makeSize(25,`"${i}"`))),e.alignedLog("left","\n")})),a.onReceive((async t=>{e.alignedLog("right",`${i} received:`),e.alignedLog("right",e.makeColor([64,192,64],e.makeSize(25,`"${t}"`))),e.alignedLog("right","\n")})),await Promise.all([r.initialize(),a.initialize()]),e.logCenter(e.makeBorder("[unencrypted] Client A send to Client B")),e.logLeft(`${t} now sending a message:`);const o="Hello, is this safe?";for(e.alignedLog("left",e.makeColor([64,192,64],e.makeSize(25,`"${o}"`))),e.log("\n"),r.send(o);s.hasMessageToSend()||n.hasMessageToSend();)await s.pipeMessages(n),await n.pipeMessages(s);e.logCenter(e.makeBorder("[unencrypted] Client B send to Client A")),e.logRight(`${i} now sending a message:`);const l="Hi, no... it isn't safe...";for(e.alignedLog("right",e.makeColor([64,192,64],e.makeSize(25,`"${l}"`))),e.log("\n"),a.send(l);s.hasMessageToSend()||n.hasMessageToSend();)await s.pipeMessages(n),await n.pipeMessages(s);for(e.logCenter(e.makeBorder("Client A send request for encryption to Client B")),await r.makeSecure();s.hasMessageToSend()||n.hasMessageToSend();)await s.pipeMessages(n),await n.pipeMessages(s);e.logCenter(e.makeBorder("Client B sent a reply for encryption to Client B")),e.logCenter(e.makeBorder("Both Client A and Client B can now encrypt/decrypt each other messages")),e.logCenter(e.makeBorder("[encrypted] Client A send to Client B")),e.logLeft(`${t} now sending a message:`);const c="Let's try again, safe now?";e.alignedLog("left",e.makeColor([64,192,64],e.makeSize(25,`"${c}"`))),e.log("\n"),r.send(c),await s.pipeMessages(n),e.logCenter(e.makeBorder("[encrypted] Client B send to Client A")),e.logRight(`${i} now sending a message:`);const g="I'd say we're pretty safe right now :)";e.alignedLog("right",e.makeColor([64,192,64],e.makeSize(25,`"${g}"`))),e.log("\n"),a.send(g),await n.pipeMessages(s),r.delete(),a.delete(),e.logCenter(e.makeColor([128,128,0],e.makeSize(30,e.makeBorder("Secure Connection Test"))))})(n);const o=Date.now();n.logCenter(n.makeColor([255,0,0],`\n\nSTOP (${o-i}ms)\n\n`))};
